# 详细设计文档：占位符清理机制

**文档编号**: TD-2026-02-01-001
**版本**: v1.0
**作者**: Agent2 (开发)
**日期**: 2026-02-01
**状态**: 设计中

---

## 一、概述

### 1.1 背景

黑盒测试发现：LLM生成的证据文件包含大量占位符（`某某`、`某公司`、`X4`、`X年月日`等），仅靠Prompt约束无法完全解决。

**当前问题**：
- 证据验证通过率：5.7%
- 占位符类型：`某某`、`某公司`、`X4`、`【】`、空白括号等

### 1.2 目标

实现代码层的占位符检测和自动重试机制，确保：
1. 证据文件不再包含占位符
2. 证据验证通过率达到 **95%** 以上
3. PDF脱敏检查通过

---

## 二、系统设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Stage1Service                             │
│                                                             │
│  ┌──────────────┐    ┌────────────────┐    ┌─────────────┐ │
│  │ Generate      │───>│ RetryHandler   │───>│ Final       │ │
│  │ Evidence      │    │ (max_retries=3)│    │ Output      │ │
│  └──────────────┘    └────────────────┘    └─────────────┘ │
│                              │                                │
│                              ▼                                │
│                     ┌────────────────┐                        │
│                     │ Placeholder    │                        │
│                     │ Checker        │                        │
│                     └────────────────┘                        │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 组件职责

| 组件 | 职责 |
|------|------|
| PlaceholderChecker | 检测文本中的占位符模式 |
| RetryHandler | 控制重试逻辑和失败降级 |
| Stage1Service | 调用生成函数并集成检查机制 |

---

## 三、详细设计

### 3.1 占位符检测器 (src/utils/placeholder_checker.py)

#### 3.1.1 类定义

```python
"""占位符检测器"""
import re
from typing import List, Tuple, Set
from loguru import logger


class PlaceholderChecker:
    """检测文本中的占位符模式"""
    
    def __init__(self):
        """初始化占位符检测器"""
        # 占位符正则表达式模式
        self.patterns = [
            (r'某某\w*', '某某开头占位符（如某某公司、某某银行）'),
            (r'某\w{1,3}', '某开头短占位符（如某人、某公司）'),
            (r'X\d+', 'X+数字占位符（如X4、X5）'),
            (r'X年X月X日', '日期占位符'),
            (r'[X×]\d+%', '百分比占位符（如X%、X5%）'),
            (r'[X×]\d+', '数字占位符'),
            (r'【\s*】', '方括号占位符'),
            (r'（\s*）', '圆括号占位符'),
            (r'\(\s*\)', '英文圆括号占位符'),
            (r'或授权代表', '未填充的签名占位符'),
            (r'二〇\d{2}年\d{1,2}月\d{1,2}日', '未填充日期占位符'),
        ]
    
    def check(self, text: str) -> Tuple[bool, List[str]]:
        """
        检测文本中的占位符
        
        Args:
            text: 待检测的文本
            
        Returns:
            Tuple[是否有占位符, 占位符列表]
        """
        found_placeholders = []
        
        for pattern, description in self.patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                # 去重
                placeholder = str(match)
                if placeholder not in found_placeholders:
                    found_placeholders.append(placeholder)
        
        # 检查是否有空白占位符（连续的方括号或圆括号）
        empty_bracket_patterns = [
            r'【\s*】',
            r'（\s*）',
            r'\(\s*\)',
        ]
        for pattern in empty_bracket_patterns:
            if re.search(pattern, text):
                if '【】' not in found_placeholders:
                    found_placeholders.append('【】')
                if '（）' not in found_placeholders:
                    found_placeholders.append('（）')
        
        return len(found_placeholders) == 0, found_placeholders
    
    def check_file(self, file_path: str) -> Tuple[bool, List[str]]:
        """
        检测文件中的占位符
        
        Args:
            file_path: 文件路径
            
        Returns:
            Tuple[是否有占位符, 占位符列表]
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            text = f.read()
        return self.check(text)
    
    def get_placeholder_count(self, text: str) -> int:
        """
        统计占位符数量
        
        Args:
            text: 待检测的文本
            
        Returns:
            占位符数量
        """
        _, placeholders = self.check(text)
        return len(placeholders)
    
    def has_any_placeholder(self, text: str) -> bool:
        """
        快速检查是否存在占位符
        
        Args:
            text: 待检测的文本
            
        Returns:
            是否存在占位符
        """
        is_clean, _ = self.check(text)
        return not is_clean
```

#### 3.1.2 测试用例

```python
import unittest

class TestPlaceholderChecker(unittest.TestCase):
    def test_has_placeholder_某某(self):
        checker = PlaceholderChecker()
        text = "某某公司5签署合同"
        is_clean, found = checker.check(text)
        self.assertFalse(is_clean)
        self.assertIn("某某公司5", found)
    
    def test_has_placeholder_X4(self):
        checker = PlaceholderChecker()
        text = "按X4计算违约金"
        is_clean, found = checker.check(text)
        self.assertFalse(is_clean)
        self.assertIn("X4", found)
    
    def test_clean_text(self):
        checker = PlaceholderChecker()
        text = "华夏金融租赁有限公司签署合同"
        is_clean, _ = checker.check(text)
        self.assertTrue(is_clean)
    
    def test_empty_brackets(self):
        checker = PlaceholderChecker()
        text = "开户行：银行支行【】账号："
        is_clean, found = checker.check(text)
        self.assertFalse(is_clean)
```

---

### 3.2 重试处理器 (src/utils/retry_handler.py)

#### 3.2.1 类定义

```python
"""重试处理器"""
from typing import Callable, Any, Optional, Dict, List
from loguru import logger
from src.utils.placeholder_checker import PlaceholderChecker


class RetryHandler:
    """带占位符检测的生成重试处理器"""
    
    def __init__(self, max_retries: int = 3):
        """
        初始化重试处理器
        
        Args:
            max_retries: 最大重试次数，默认3次
        """
        self.max_retries = max_retries
        self.checker = PlaceholderChecker()
        self.retry_count = 0
        self.retry_history: List[Dict] = []
    
    def execute_with_retry(
        self,
        generate_func: Callable,
        *args,
        **kwargs
    ) -> Dict[str, Any]:
        """
        执行生成函数，自动重试直到占位符被清除
        
        Args:
            generate_func: 生成函数
            *args: 生成函数的位置参数
            **kwargs: 生成函数的关键字参数
            
        Returns:
            Dict包含:
                - success: bool, 是否成功
                - result: str, 生成结果
                - attempts: int, 尝试次数
                - placeholders: List[str], 发现的占位符
                - error: str, 错误信息（如有）
        """
        self.retry_count = 0
        self.retry_history = []
        
        for attempt in range(self.max_retries + 1):
            self.retry_count = attempt
            
            try:
                # 调用生成函数
                result = generate_func(*args, **kwargs)
                
                # 检查占位符
                is_clean, placeholders = self.checker.check(result)
                
                retry_info = {
                    "attempt": attempt + 1,
                    "success": is_clean,
                    "placeholders": placeholders,
                    "has_result": result is not None
                }
                self.retry_history.append(retry_info)
                
                if is_clean:
                    logger.success(f"生成成功，第{attempt + 1}次尝试，占位符数量: 0")
                    return {
                        "success": True,
                        "result": result,
                        "attempts": attempt + 1,
                        "placeholders": [],
                        "error": None
                    }
                else:
                    logger.warning(
                        f"尝试 {attempt + 1}/{self.max_retries + 1} 失败，"
                        f"发现 {len(placeholders)} 个占位符: {placeholders[:5]}..."
                    )
            
            except Exception as e:
                logger.error(f"尝试 {attempt + 1} 发生异常: {e}")
                self.retry_history.append({
                    "attempt": attempt + 1,
                    "success": False,
                    "placeholders": [],
                    "error": str(e),
                    "has_result": False
                })
        
        # 所有尝试都失败
        logger.error(
            f"重试 {self.max_retries + 1} 次后仍失败，"
            f"最后发现的占位符: {self.retry_history[-1].get('placeholders', [])}"
        )
        
        return {
            "success": False,
            "result": None,
            "attempts": self.max_retries + 1,
            "placeholders": self.retry_history[-1].get("placeholders", []),
            "error": "超过最大重试次数，占位符仍未清除"
        }
    
    def get_retry_stats(self) -> Dict[str, Any]:
        """
        获取重试统计信息
        
        Returns:
            统计信息字典
        """
        total_attempts = len(self.retry_history)
        successful_first_try = (
            total_attempts > 0 and 
            self.retry_history[0].get("success", False)
        )
        
        return {
            "total_attempts": total_attempts,
            "first_try_success": successful_first_try,
            "max_retries": self.max_retries,
            "retry_count": self.retry_count,
            "history": self.retry_history
        }
```

#### 3.2.2 测试用例

```python
class TestRetryHandler(unittest.TestCase):
    def test_first_try_success(self):
        def generate_success():
            return "华夏金融租赁有限公司签署合同"
        
        handler = RetryHandler(max_retries=3)
        result = handler.execute_with_retry(generate_success)
        
        self.assertTrue(result["success"])
        self.assertEqual(result["attempts"], 1)
    
    def test_retry_until_success(self):
        call_count = 0
        
        def generate_with_placeholder():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                return "某某公司5签署合同"
            return "华夏金融租赁有限公司签署合同"
        
        handler = RetryHandler(max_retries=3)
        result = handler.execute_with_retry(generate_with_placeholder)
        
        self.assertTrue(result["success"])
        self.assertEqual(result["attempts"], 2)
        self.assertEqual(call_count, 2)
    
    def test_all_attempts_failed(self):
        def always_has_placeholder():
            return "某某公司5签署合同，金额X4元"
        
        handler = RetryHandler(max_retries=2)
        result = handler.execute_with_retry(always_has_placeholder)
        
        self.assertFalse(result["success"])
        self.assertEqual(result["attempts"], 3)
```

---

### 3.3 集成方案 (stage1_service.py)

#### 3.3.1 修改内容

在 `Stage1Service` 中集成占位符检查：

```python
from src.utils.placeholder_checker import PlaceholderChecker
from src.utils.retry_handler import RetryHandler

class Stage1Service:
    def __init__(self, prompt_dir: str = "prompts", output_dir: str = "outputs"):
        # ... 现有初始化代码 ...
        
        # 初始化占位符检查器
        self.checker = PlaceholderChecker()
        self.retry_handler = RetryHandler(max_retries=3)
    
    def _generate_with_check(
        self,
        generate_func: Callable,
        evidence_data: Dict,
        *args, **kwargs
    ) -> Dict[str, Any]:
        """
        带占位符检查的生成方法
        
        Args:
            generate_func: 生成函数
            evidence_data: 证据数据
            *args, **kwargs: 其他参数
            
        Returns:
            生成结果
        """
        # 使用重试处理器执行生成
        result = self.retry_handler.execute_with_retry(
            generate_func,
            evidence_data,
            *args, **kwargs
        )
        
        if result["success"]:
            return {
                "success": True,
                "content": result["result"],
                "attempts": result["attempts"],
                "placeholders": []
            }
        else:
            # 降级处理：记录错误但继续
            logger.error(
                f"生成失败，已重试 {result['attempts']} 次，"
                f"占位符: {result['placeholders']}"
            )
            return {
                "success": False,
                "content": result["result"],
                "attempts": result["attempts"],
                "placeholders": result["placeholders"],
                "error": result["error"]
            }
```

#### 3.3.2 修改点清单

| 文件 | 修改内容 |
|------|---------|
| `src/services/stage1/stage1_service.py` | 1. 导入PlaceholderChecker和RetryHandler<br>2. `__init__`中初始化检查器和重试处理器<br>3. `_generate_evidence_file`调用`_generate_with_check` |
| `src/services/evidence_file_generator.py` | 1. 导入检查器<br>2. `generate_all_evidence_files`中使用重试机制 |

---

## 四、文件清单

### 4.1 新增文件

| 文件路径 | 说明 |
|---------|------|
| `src/utils/placeholder_checker.py` | 占位符检测器 |
| `src/utils/retry_handler.py` | 重试处理器 |
| `tests/unit/test_placeholder_checker.py` | 占位符检测器单元测试 |
| `tests/unit/test_retry_handler.py` | 重试处理器单元测试 |

### 4.2 修改文件

| 文件路径 | 修改内容 |
|---------|---------|
| `src/services/stage1/stage1_service.py` | 集成占位符检查机制 |
| `src/services/evidence_file_generator.py` | 集成重试机制 |

---

## 五、验收标准

1. **功能验收**
   - [ ] 占位符检测器能识别所有已知占位符模式
   - [ ] 重试机制在发现占位符时自动重新生成
   - [ ] 超过最大重试次数后正确降级处理

2. **性能验收**
   - [ ] 重试机制不显著增加生成时间（单次重试<5秒）
   - [ ] 占位符检测性能满足批量处理需求

3. **质量验收**
   - [ ] 证据验证通过率达到 **95%** 以上
   - [ ] PDF脱敏检查通过
   - [ ] 所有单元测试通过（22/22）

---

## 六、风险与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|------|--------|------|---------|
| LLM始终生成占位符 | 低 | 高 | 调整Prompt模板，增加示例 |
| 重试导致超时 | 中 | 中 | 设置超时限制，最大重试3次 |
| 误判（将正常文本识别为占位符） | 低 | 低 | 添加白名单机制 |

---

## 七、时间估算

| 任务 | 预估时间 |
|------|---------|
| 占位符检测器开发 | 1小时 |
| 重试处理器开发 | 1小时 |
| 集成到stage1_service | 1小时 |
| 单元测试 | 1小时 |
| 集成测试 | 1小时 |
| **总计** | **5小时** |

---

**文档版本**: v1.0
**创建日期**: 2026-02-01
**最后更新**: 2026-02-01
